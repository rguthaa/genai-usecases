[
  {
    "title": "Authentication Overview",
    "url": "https://confluence.company.com/display/ENG/Auth+Overview",
    "content": "This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for in"
  },
  {
    "title": "Authentication Overview (v4)",
    "url": "https://confluence.company.com/display/ENG-V4/Auth+Overview",
    "content": "This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for internal APIs. Login flows for web and mobile are unified via the Auth Gateway. This document provides an overview of the authentication mechanisms used in our platform. We use OAuth 2.0 for third-party integrations and JWT-based session tokens for in Disclaimer: Document style varies slightly across departments."
  },
  {
    "title": "Deployment Process",
    "url": "https://confluence.company.com/display/ENG/Deployment+Process",
    "content": "All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/C"
  },
  {
    "title": "Deployment Process (v4)",
    "url": "https://confluence.company.com/display/ENG-V4/Deployment+Process",
    "content": "All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/CD pipeline powered by GitLab and ArgoCD. Developers merge into `main`, which triggers staging deployments. Production releases require manual approval and are tagged with semantic versions. All services are deployed through our CI/C Update: The details were confirmed by the security team."
  },
  {
    "title": "Error Logging and Monitoring",
    "url": "https://confluence.company.com/display/ENG/Error+Logging+Monitoring",
    "content": "Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-l"
  },
  {
    "title": "Error Logging and Monitoring (v2)",
    "url": "https://confluence.company.com/display/ENG-V2/Error+Logging+Monitoring",
    "content": "Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-level errors to Datadog. Frontend apps report errors via a JS SDK, while backend logs are centralized through Fluent Bit and streamed to Elasticsearch. Critical alerts trigger Slack notifications. Our platform logs all application-l Rewritten based on the API team\u2019s documentation."
  },
  {
    "title": "Database Schema Guidelines",
    "url": "https://confluence.company.com/display/ENG/DB+Schema+Guidelines",
    "content": "When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless nece"
  },
  {
    "title": "Database Schema Guidelines (v5)",
    "url": "https://confluence.company.com/display/ENG-V5/DB+Schema+Guidelines",
    "content": "When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless necessary. When designing new tables, always use snake_case and include created_at and updated_at timestamps. Use UUIDs for primary keys and avoid nullable foreign keys unless nece Note: This version was updated with team-specific instructions."
  },
  {
    "title": "API Versioning Strategy",
    "url": "https://confluence.company.com/display/ENG/API+Versioning",
    "content": "All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trig"
  },
  {
    "title": "API Versioning Strategy (v4)",
    "url": "https://confluence.company.com/display/ENG-V4/API+Versioning",
    "content": "All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trigger a major version bump. We use OpenAPI specifications for documentation and client generation. All public APIs are versioned using the URL path strategy. Breaking changes must trig Disclaimer: Document style varies slightly across departments."
  },
  {
    "title": "Incident Response Protocol",
    "url": "https://confluence.company.com/display/ENG/Incident+Response",
    "content": "During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours usin"
  },
  {
    "title": "Incident Response Protocol (v5)",
    "url": "https://confluence.company.com/display/ENG-V5/Incident+Response",
    "content": "During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours using the provided RCA template. During a P1 incident, notify the incident channel, assign a lead, and initiate a Zoom bridge. Post-incident, complete a blameless RCA within 72 hours usin Update: The details were confirmed by the security team."
  },
  {
    "title": "Onboarding Checklist for Engineers",
    "url": "https://confluence.company.com/display/ENG/Engineer+Onboarding",
    "content": "New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a"
  },
  {
    "title": "Onboarding Checklist for Engineers (v3)",
    "url": "https://confluence.company.com/display/ENG-V3/Engineer+Onboarding",
    "content": "New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a walkthrough with their onboarding buddy within the first week. New engineers should complete access requests, clone relevant repos, set up their dev environment, and schedule a Update: The details were confirmed by the security team."
  },
  {
    "title": "Frontend Architecture",
    "url": "https://confluence.company.com/display/ENG/Frontend+Architecture",
    "content": "Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component d"
  },
  {
    "title": "Frontend Architecture (v5)",
    "url": "https://confluence.company.com/display/ENG-V5/Frontend+Architecture",
    "content": "Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component development and testing. Our frontend stack uses React, TypeScript, and Tailwind CSS. State management is handled via Redux Toolkit, and we use Storybook for UI component d Note: This version was updated with team-specific instructions."
  },
  {
    "title": "Security Best Practices",
    "url": "https://confluence.company.com/display/ENG/Security+Best+Practices",
    "content": "Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal"
  },
  {
    "title": "Security Best Practices (v2)",
    "url": "https://confluence.company.com/display/ENG-V2/Security+Best+Practices",
    "content": "Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal tools and rotate credentials every 90 days. Always use environment variables for secrets. All endpoints must be authenticated and authorized. Enable 2FA for all internal Additional info: This content reflects feedback from the onboarding session."
  },
  {
    "title": "Data Retention Policy",
    "url": "https://confluence.company.com/display/ENG/Data+Retention",
    "content": "Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for"
  },
  {
    "title": "Data Retention Policy (v5)",
    "url": "https://confluence.company.com/display/ENG-V5/Data+Retention",
    "content": "Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for 90 days. All policies are compliant with GDPR and SOC2. Customer data is retained for 7 years unless deletion is requested. Logs are retained for 30 days and backups for Disclaimer: Document style varies slightly across departments."
  },
  {
    "title": "Feature Flag Framework",
    "url": "https://confluence.company.com/display/ENG/Feature+Flags",
    "content": "We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use Launc"
  },
  {
    "title": "Feature Flag Framework (v3)",
    "url": "https://confluence.company.com/display/ENG-V3/Feature+Flags",
    "content": "We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use LaunchDarkly to manage feature flags. Each flag must be documented and tagged with owner, rollout strategy, and expiry. Flags should be removed within 2 sprints after full rollout. We use Launc Update: The details were confirmed by the security team."
  },
  {
    "title": "Mobile App Release Workflow",
    "url": "https://confluence.company.com/display/ENG/Mobile+Releases",
    "content": "Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed"
  },
  {
    "title": "Mobile App Release Workflow (v4)",
    "url": "https://confluence.company.com/display/ENG-V4/Mobile+Releases",
    "content": "Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed to TestFlight/Play Store using internal release channels before going public. Mobile releases are triggered via GitHub Actions, signed via Fastlane, and deployed Additional info: This content reflects feedback from the onboarding session."
  },
  {
    "title": "Slack Channel Naming Convention",
    "url": "https://confluence.company.com/display/ENG/Slack+Channels",
    "content": "All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and m"
  },
  {
    "title": "Slack Channel Naming Convention (v3)",
    "url": "https://confluence.company.com/display/ENG-V3/Slack+Channels",
    "content": "All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and must have a pinned description. All Slack channels follow the format `team-purpose` (e.g., `eng-infra`, `design-feedback`). Archived channels are reviewed quarterly and m Rewritten based on the API team\u2019s documentation."
  },
  {
    "title": "Internal Tool Access Requests",
    "url": "https://confluence.company.com/display/ENG/Tool+Access",
    "content": "Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal"
  },
  {
    "title": "Internal Tool Access Requests (v2)",
    "url": "https://confluence.company.com/display/ENG-V2/Tool+Access",
    "content": "Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal tools is managed through Okta workflows. All requests must go through the access-requests Slack channel and require manager approval. Access to internal Rewritten based on the API team\u2019s documentation."
  },
  {
    "title": "Service Ownership Guidelines",
    "url": "https://confluence.company.com/display/ENG/Service+Ownership",
    "content": "Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed"
  },
  {
    "title": "Service Ownership Guidelines (v3)",
    "url": "https://confluence.company.com/display/ENG-V3/Service+Ownership",
    "content": "Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed in the service catalog. Owners are responsible for uptime, documentation, alerts, and incident response. Every microservice must have an owner listed Disclaimer: Document style varies slightly across departments."
  }
]